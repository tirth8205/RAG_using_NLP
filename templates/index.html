<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG using NLP: PDF Q&A</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&Lora:wght@400;600&Roboto:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #f7f7f7, #e8e8e8);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            font-family: 'Roboto', sans-serif;
        }
        .container {
            background: linear-gradient(135deg, #fdfdfd, #f0f0f0); /* Slightly lighter container */
            border-radius: 20px;
            padding: 30px 40px; /* Adjusted padding */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15); /* Softer shadow */
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }
        .left-section, .right-section {
            flex: 1;
            min-width: 300px;
            padding: 10px; /* Added padding for sections */
        }
        .right-section {
            flex: 1.5; /* Give a bit more space to the answer */
        }
        h1 {
            font-family: 'Playfair Display', serif;
            color: #2c3e50; /* Darker, more professional color */
            text-align: center;
            font-size: 2.6em; /* Slightly adjusted */
            margin-bottom: 15px;
            width: 100%;
        }
        .description {
            font-family: 'Lora', serif;
            text-align: center;
            font-size: 1.2em; /* Adjusted */
            color: #555;
            margin-bottom: 30px;
            width: 100%;
        }
        label {
            font-family: 'Lora', serif;
            font-weight: 600;
            color: #333;
            font-size: 1.1em; /* Adjusted */
            margin-bottom: 8px; /* Adjusted */
            display: block;
        }
        input[type="file"], textarea, input[type="text"] {
            font-family: 'Roboto', sans-serif;
            border: 1px solid #ccc; /* Lighter border */
            border-radius: 8px; /* Softer radius */
            padding: 10px 12px; /* Adjusted padding */
            width: 100%;
            background-color: #fff; /* White background for inputs */
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            margin-bottom: 18px; /* Adjusted */
            color: #333;
        }
        input[type="file"]::placeholder, textarea::placeholder, input[type="text"]::placeholder {
            color: #888; /* Lighter placeholder */
        }
        input[type="file"]:focus, textarea:focus, input[type="text"]:focus {
            border-color: #007bff; /* Bootstrap blue for focus */
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
            outline: none;
        }
        textarea {
            height: 100px; /* Adjusted */
            resize: vertical; /* Allow vertical resize */
        }
        input[type="file"]::file-selector-button {
            font-family: 'Roboto', sans-serif;
            background-color: #007bff; /* Primary button color */
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: #ffffff;
            margin-right: 10px; /* Space after button */
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #0056b3; /* Darker on hover */
        }
        .button-container {
            text-align: center;
            margin-top: 15px; /* Adjusted */
            width: 100%; /* Ensure buttons are centered within their section */
        }
        button {
            font-family: 'Roboto', sans-serif;
            font-weight: 500; /* Medium weight */
            background-color: #28a745; /* Green for submit */
            color: white;
            border: none;
            border-radius: 20px; /* Pill shape */
            padding: 10px 30px; /* Adjusted padding */
            font-size: 1.1em; /* Adjusted */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin: 0 8px; /* Adjusted margin */
        }
        button:hover {
            background-color: #218838; /* Darker green */
            transform: translateY(-1px); /* Slight lift */
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        #clear-btn {
            background-color: #dc3545; /* Red for clear */
        }
        #clear-btn:hover {
            background-color: #c82333; /* Darker red */
        }
        #answer { /* Answer box */
            height: 280px; /* Adjusted */
            background-color: #e9ecef; /* Light gray for readonly */
            border-color: #ced4da;
        }
        .status-container { /* New container for status messages */
            width:100%;
            margin-top: 15px;
        }
        #status-messages {
            font-family: 'Roboto Mono', monospace; /* Monospace for status */
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-top: 5px; /* Space from its label */
            background-color: #f8f9fa;
            color: #333;
            min-height: 60px;
            max-height: 180px; /* Limit height */
            overflow-y: auto; /* Scroll for overflow */
            white-space: pre-line; /* Respect newlines */
            font-size: 0.9em;
            line-height: 1.6;
        }
        .footer {
            font-family: 'Lora', serif;
            text-align: center;
            font-size: 1em; /* Adjusted */
            color: #666; /* Subtler footer color */
            margin-top: 35px;
            padding: 10px;
            width: 100%;
            border-top: 1px solid #eee; /* Separator line */
        }
        .footer span {
            color: #007bff; /* Brand color for name */
            font-weight: bold;
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 20px;
            }
            .left-section, .right-section {
                min-width: 100%;
                flex-basis: auto; /* Allow sections to take natural height */
            }
            h1 { font-size: 2.2em; }
            .description { font-size: 1.1em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RAG using NLP: PDF Q&A</h1>
        <p class="description">Upload a PDF, ask a question, and get answers based on its content. Watch the progress below!</p>

        <div class="left-section">
            <label for="model-id">Hugging Face Model ID</label>
            <input type="text" id="model-id" placeholder="e.g., google/gemma-2b-it" value="google/gemma-2b-it">

            <label for="pdf-input">Upload PDF</label>
            <input type="file" id="pdf-input" accept=".pdf">

            <label for="query-input">Your Question</label>
            <textarea id="query-input" placeholder="e.g., What is User Awareness?"></textarea>

            <div class="button-container">
                <button id="clear-btn">Clear</button>
                <button id="submit-btn">Submit</button>
            </div>
        </div>

        <div class="right-section">
            <label for="answer">Answer</label>
            <textarea id="answer" readonly placeholder="The generated answer will appear here..."></textarea>

            <div class="status-container"> <label for="status-messages">Processing Status:</label>
                <div id="status-messages">Waiting for submission...</div>
            </div>
        </div>

        <div class="footer">
            Made with ❤️ by <span>Tirth</span>
        </div>
    </div>

    <script>
        const submitBtn = document.getElementById('submit-btn');
        const clearBtn = document.getElementById('clear-btn');
        const pdfInput = document.getElementById('pdf-input');
        const queryInput = document.getElementById('query-input');
        const modelIdInput = document.getElementById('model-id');
        const answerBox = document.getElementById('answer');
        const statusBox = document.getElementById('status-messages');
        let eventSource = null;

        submitBtn.addEventListener('click', async () => {
            const pdfFile = pdfInput.files[0];
            const query = queryInput.value;
            const modelId = modelIdInput.value;

            if (!pdfFile || !query || !modelId) {
                answerBox.value = 'Please upload a PDF, enter a query, and specify a model ID.';
                statusBox.textContent = 'Error: Missing inputs.';
                return;
            }

            answerBox.value = '';
            statusBox.innerHTML = 'Initializing request...<br>';
            submitBtn.disabled = true;
            clearBtn.disabled = true;

            const formData = new FormData();
            formData.append('pdf_file', pdfFile);
            formData.append('query', query);
            formData.append('model_id', modelId);

            if (eventSource) {
                eventSource.close(); // Close any existing connection
            }

            // Standard EventSource API expects a GET request.
            // To send FormData (with a file) via POST and still get an SSE stream,
            // we need to make sure the server is set up correctly.
            // The EventSourceResponse in FastAPI can handle being returned from a POST endpoint.
            // The key is how the client initiates it. The `EventSource` constructor itself forms a GET.
            //
            // A common pattern is to use `Workspace` for the POST and then handle the streaming response manually
            // if the server sets `Content-Type: text/event-stream`.
            // However, `EventSourceResponse` from `sse-starlette` when returned from a POST endpoint
            // should work with a standard `EventSource` client if the client forms the URL correctly
            // by including query parameters for non-file data if needed, and the server can access
            // form data from the POST that *initiated* the `EventSourceResponse`.
            //
            // Let's try constructing the EventSource URL with query parameters for non-file data
            // and rely on FastAPI to handle the file from the POST that returns this EventSourceResponse.
            // This is a bit of a gray area with standard EventSource client.
            // The most robust way is to use fetch to get the stream, as done in a previous iteration.
            //
            // For this implementation, assuming `app.post("/stream-process")` can receive form-data
            // AND `EventSourceResponse` correctly streams back:
            // We need to initiate the POST request that returns the SSE stream.
            // The `EventSource` JavaScript API itself makes a GET request. This is the tricky part.

            // Simplest way if server supports it (FastAPI/Starlette can):
            // The POST request is implied by the form submission to the endpoint
            // that then returns the EventSourceResponse. The EventSource client
            // would then connect to that *same URL* (which just served the initial HTML or an API call)
            // and the server must be smart enough to start streaming.
            // This is usually done by POSTing to an endpoint that starts a task and returns a task ID,
            // then EventSource connects to /stream/<task_id> (GET).

            // Given our single /stream-process POST endpoint returning EventSourceResponse:
            // We'll use the `Workspace` approach for the POST that gets a streaming body.

            try {
                const response = await fetch('/stream-process', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok || !response.body) {
                    const errorText = await response.text();
                    statusBox.innerHTML += `Error starting stream: ${response.status} ${response.statusText}. ${errorText}<br>`;
                    answerBox.value = `Error: Failed to start processing. ${errorText}`;
                    submitBtn.disabled = false;
                    clearBtn.disabled = false;
                    return;
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                function processText(text) {
                    buffer += text;
                    let boundary = buffer.indexOf('\n\n');
                    while (boundary !== -1) {
                        const message = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2); // Skip '\n\n'
                        if (message.trim() === '') {
                            boundary = buffer.indexOf('\n\n');
                            continue;
                        }

                        let eventType = 'message'; // Default
                        let eventData = '';

                        message.split('\n').forEach(line => {
                            if (line.startsWith('event: ')) {
                                eventType = line.substring('event: '.length).trim();
                            } else if (line.startsWith('data: ')) {
                                eventData = line.substring('data: '.length).trim();
                            }
                            // Ignoring 'id:' and 'retry:' for this example
                        });

                        if (eventData) {
                           // Try to parse if it looks like JSON, otherwise treat as string
                           let parsedData = eventData;
                           if (eventData.startsWith('{') && eventData.endsWith('}')) {
                               try { parsedData = JSON.parse(eventData); } catch (e) { /* ignore, treat as string */ }
                           }

                            if (eventType === 'final_answer') {
                                answerBox.value = parsedData; // `parsedData` is the answer string
                                statusBox.innerHTML += `<strong>Answer received.</strong><br>`;
                            } else if (eventType === 'error') {
                                statusBox.innerHTML += `<strong style="color: red;">Error: ${parsedData}</strong><br>`;
                                answerBox.value = `Error: ${parsedData}`;
                            } else if (eventType === 'status') {
                                statusBox.innerHTML += `${parsedData}<br>`;
                            } else { // Generic message event
                                statusBox.innerHTML += `Update: ${parsedData}<br>`;
                            }
                            statusBox.scrollTop = statusBox.scrollHeight;
                        }
                        boundary = buffer.indexOf('\n\n');
                    }
                }

                async function readStream() {
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                if (buffer.trim()) processText(''); // Process any remaining buffer
                                statusBox.innerHTML += "Stream closed by server.<br>";
                                break;
                            }
                            processText(decoder.decode(value, { stream: true }));
                        }
                    } catch (streamError) {
                        console.error('Stream reading error:', streamError);
                        statusBox.innerHTML += `<strong style="color: red;">Stream connection error: ${streamError.message}</strong><br>`;
                    } finally {
                        submitBtn.disabled = false;
                        clearBtn.disabled = false;
                    }
                }
                readStream();

            } catch (error) {
                console.error('Fetch POST error:', error);
                answerBox.value = 'Error: ' + error.message;
                statusBox.textContent = 'Error: ' + error.message;
                submitBtn.disabled = false;
                clearBtn.disabled = false;
            }
        });

        clearBtn.addEventListener('click', () => {
            pdfInput.value = '';
            queryInput.value = '';
            modelIdInput.value = 'google/gemma-2b-it';
            answerBox.value = '';
            statusBox.textContent = 'Cleared. Waiting for submission...';
            // If using the native EventSource, you would do: if (eventSource) eventSource.close();
            // With fetch, closing is managed by the stream ending or aborting the fetch (more complex).
            // For simplicity, we are not implementing fetch abort here.
            submitBtn.disabled = false;
        });
    </script>
</body>
</html>